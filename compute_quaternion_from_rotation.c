#include "header.h"

void compute_quaternion_from_rotation(
 double M[3*3],
 double q[4]
)

/*
Code taken from stuff8/pba_v1.0.5/pba/src/pba/DataInterface.h
*/

{

    /* original code
    template <class Float>     void GetQuaternionRotation(Float q[4]) const
    {
        q[0]= 1 + m[0][0] + m[1][1] + m[2][2];
        if(q[0]>0.000000001)
        {
            q[0] = sqrt(q[0])/2.0;
            q[1]= (m[2][1] - m[1][2])/( 4.0 *q[0]);
            q[2]= (m[0][2] - m[2][0])/( 4.0 *q[0]);
            q[3]= (m[1][0] - m[0][1])/( 4.0 *q[0]);
        }else
        {
            double s;
            if ( m[0][0] > m[1][1] && m[0][0] > m[2][2] )
            {
              s = 2.0 * sqrt( 1.0 + m[0][0] - m[1][1] - m[2][2]);
              q[1] = 0.25 * s;
              q[2] = (m[0][1] + m[1][0] ) / s;
              q[3] = (m[0][2] + m[2][0] ) / s;
              q[0] = (m[1][2] - m[2][1] ) / s;
            } else if (m[1][1] > m[2][2])
            {
              s = 2.0 * sqrt( 1.0 + m[1][1] - m[0][0] - m[2][2]);
              q[1] = (m[0][1] + m[1][0] ) / s;
              q[2] = 0.25 * s;
              q[3] = (m[1][2] + m[2][1] ) / s;
              q[0] = (m[0][2] - m[2][0] ) / s;
            } else
            {
              s = 2.0 * sqrt( 1.0 + m[2][2] - m[0][0] - m[1][1] );
              q[1] = (m[0][2] + m[2][0] ) / s;
              q[2] = (m[1][2] + m[2][1] ) / s;
              q[3] = 0.25f * s;
              q[0] = (m[0][1] - m[1][0] ) / s;
            }
        }
    }
    */

    double m[3][3];
    int i;
    int j;

    for ( i= 0 ; i< 3 ; i++ ) {
       for ( j= 0 ; j< 3 ; j++ ) {
          m[i][j]= M[i*3+j];
       }
    }

        q[0]= 1 + m[0][0] + m[1][1] + m[2][2];
        if(q[0]>0.000000001)
        {
            q[0] = sqrt(q[0])/2.0;
            q[1]= (m[2][1] - m[1][2])/( 4.0 *q[0]);
            q[2]= (m[0][2] - m[2][0])/( 4.0 *q[0]);
            q[3]= (m[1][0] - m[0][1])/( 4.0 *q[0]);
        }else
        {
            double s;
            if ( m[0][0] > m[1][1] && m[0][0] > m[2][2] )
            {
              s = 2.0 * sqrt( 1.0 + m[0][0] - m[1][1] - m[2][2]);
              q[1] = 0.25 * s;
              q[2] = (m[0][1] + m[1][0] ) / s;
              q[3] = (m[0][2] + m[2][0] ) / s;
              q[0] = (m[1][2] - m[2][1] ) / s;
            } else if (m[1][1] > m[2][2])
            {
              s = 2.0 * sqrt( 1.0 + m[1][1] - m[0][0] - m[2][2]);
              q[1] = (m[0][1] + m[1][0] ) / s;
              q[2] = 0.25 * s;
              q[3] = (m[1][2] + m[2][1] ) / s;
              q[0] = (m[0][2] - m[2][0] ) / s;
            } else
            {
              s = 2.0 * sqrt( 1.0 + m[2][2] - m[0][0] - m[1][1] );
              q[1] = (m[0][2] + m[2][0] ) / s;
              q[2] = (m[1][2] + m[2][1] ) / s;
              q[3] = 0.25f * s;
              q[0] = (m[0][1] - m[1][0] ) / s;
            }
        }

}
